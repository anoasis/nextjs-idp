import { Requester, Prompt, IdTokenClaims, UserInfoResponse } from "@logto/js";
import { Nullable, NormalizeKeyPaths } from "@silverhand/essentials";
export type StorageKey = 'idToken' | 'refreshToken' | 'accessToken' | 'signInSession';
export type Storage = {
    getItem(key: StorageKey): Promise<Nullable<string>>;
    setItem(key: StorageKey, value: string): Promise<void>;
    removeItem(key: StorageKey): Promise<void>;
};
type Navigate = (url: string) => void;
export type ClientAdapter = {
    requester: Requester;
    storage: Storage;
    navigate: Navigate;
    generateState: () => string;
    generateCodeVerifier: () => string;
    generateCodeChallenge: (codeVerifier: string) => Promise<string>;
};
declare const logtoClientErrorCodes: Readonly<{
    sign_in_session: {
        invalid: string;
        not_found: string;
    };
    not_authenticated: "Not authenticated.";
    get_access_token_by_refresh_token_failed: "Failed to get access token by refresh token.";
    fetch_user_info_failed: "Unable to fetch user info. The access token may be invalid.";
    invalid_id_token: "Invalid id token.";
}>;
export type LogtoClientErrorCode = NormalizeKeyPaths<typeof logtoClientErrorCodes>;
export class LogtoClientError extends Error {
    code: LogtoClientErrorCode;
    data: unknown;
    constructor(code: LogtoClientErrorCode, data?: unknown);
}
export type LogtoConfig = {
    endpoint: string;
    appId: string;
    appSecret?: string;
    scopes?: string[];
    resources?: string[];
    prompt?: Prompt;
};
export type AccessToken = {
    token: string;
    scope: string;
    expiresAt: number;
};
export const isLogtoSignInSessionItem: (data: unknown) => data is LogtoSignInSessionItem;
export const isLogtoAccessTokenMap: (data: unknown) => data is Record<string, AccessToken>;
export type LogtoSignInSessionItem = {
    redirectUri: string;
    codeVerifier: string;
    state: string;
};
export const createRequester: (fetchFunction: typeof fetch) => Requester;
export type { IdTokenClaims, LogtoErrorCode, UserInfoResponse } from '@logto/js';
export { LogtoError, OidcError, Prompt, LogtoRequestError, ReservedScope, UserScope, } from '@logto/js';
export default class LogtoClient {
    protected readonly logtoConfig: LogtoConfig;
    protected readonly getOidcConfig: () => Promise<import("@silverhand/essentials").KeysToCamelCase<import("@logto/js").OidcConfigSnakeCaseResponse>>;
    protected readonly getJwtVerifyGetKey: () => Promise<import("jose/dist/types/types").GetKeyFunction<import("jose").JWSHeaderParameters, import("jose").FlattenedJWSInput>>;
    protected readonly adapter: ClientAdapter;
    protected readonly accessTokenMap: Map<string, AccessToken>;
    constructor(logtoConfig: LogtoConfig, adapter: ClientAdapter);
    isAuthenticated(): Promise<boolean>;
    getRefreshToken(): Promise<Nullable<string>>;
    getIdToken(): Promise<Nullable<string>>;
    getAccessToken(resource?: string): Promise<string>;
    getIdTokenClaims(): Promise<IdTokenClaims>;
    fetchUserInfo(): Promise<UserInfoResponse>;
    signIn(redirectUri: string): Promise<void>;
    isSignInRedirected(url: string): Promise<boolean>;
    handleSignInCallback(callbackUri: string): Promise<void>;
    signOut(postLogoutRedirectUri?: string): Promise<void>;
    protected getSignInSession(): Promise<Nullable<LogtoSignInSessionItem>>;
    protected setSignInSession(logtoSignInSessionItem: Nullable<LogtoSignInSessionItem>): Promise<void>;
}

//# sourceMappingURL=index.d.ts.map
