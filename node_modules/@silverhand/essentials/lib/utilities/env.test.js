"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const env_1 = require("./env");
describe('getEnv()', () => {
    beforeAll(() => {
        process.env = { FOO: 'bar' };
    });
    it('returns correct env value', () => {
        expect((0, env_1.getEnv)('FOO')).toEqual('bar');
    });
    it("returns fallback if env doesn't exist", () => {
        expect((0, env_1.getEnv)('BAR', '123')).toEqual('123');
    });
});
describe('getEnvAsStringArray()', () => {
    const envBackup = process.env;
    beforeEach(() => {
        process.env = Object.assign({}, envBackup);
    });
    it('returns correct env value', () => {
        process.env = { FOO: 'bar,baz' };
        expect((0, env_1.getEnvAsStringArray)('FOO')).toEqual(['bar', 'baz']);
        process.env.NEED_TO_TRIM_VALUE = '  bar,baz  ';
        expect((0, env_1.getEnvAsStringArray)('NEED_TO_TRIM_VALUE')).toEqual(['bar', 'baz']);
    });
    it("returns fallback if env doesn't exist", () => {
        process.env = { BAR: '' };
        expect((0, env_1.getEnvAsStringArray)('BAR', ['123'])).toEqual(['123']);
    });
    it('returns empty array if env is empty', () => {
        process.env = { BAR: '' };
        expect((0, env_1.getEnvAsStringArray)('BAR')).toEqual([]);
    });
    it('returns env value as array if only one value is provided', () => {
        process.env.SINGLE = 'single';
        expect((0, env_1.getEnvAsStringArray)('SINGLE')).toEqual(['single']);
    });
});
describe('assertEnv()', () => {
    beforeAll(() => {
        process.env = { FOO: 'bar' };
    });
    it('returns correct env value', () => {
        expect((0, env_1.assertEnv)('FOO')).toEqual('bar');
    });
    it("throws an error if env doesn't exist", () => {
        expect(() => (0, env_1.assertEnv)('BAR')).toThrow('env variable BAR not found');
    });
});
describe('isNode()', () => {
    it('when running under Node', () => {
        expect((0, env_1.isNode)()).toBeTruthy();
    });
});
