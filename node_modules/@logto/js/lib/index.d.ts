import { KeysToCamelCase, NormalizeKeyPaths, Nullable } from "@silverhand/essentials";
import { JWTVerifyGetKey } from "jose";
export const ContentType: {
    formUrlEncoded: {
        'Content-Type': string;
    };
};
export enum TokenGrantType {
    AuthorizationCode = "authorization_code",
    RefreshToken = "refresh_token"
}
export enum QueryKey {
    ClientId = "client_id",
    Code = "code",
    CodeChallenge = "code_challenge",
    CodeChallengeMethod = "code_challenge_method",
    CodeVerifier = "code_verifier",
    Error = "error",
    ErrorDescription = "error_description",
    GrantType = "grant_type",
    IdToken = "id_token",
    IdTokenHint = "id_token_hint",
    PostLogoutRedirectUri = "post_logout_redirect_uri",
    Prompt = "prompt",
    RedirectUri = "redirect_uri",
    RefreshToken = "refresh_token",
    Resource = "resource",
    ResponseType = "response_type",
    Scope = "scope",
    State = "state",
    Token = "token"
}
export enum Prompt {
    Consent = "consent",
    Login = "login"
}
export enum ReservedScope {
    OpenId = "openid",
    OfflineAccess = "offline_access"
}
/**
 * Scopes for ID Token and Userinfo Endpoint.
 */
export enum UserScope {
    /**
     * Scope for basic user info.
     *
     * See {@link idTokenClaims} for mapped claims in ID Token and {@link userinfoClaims} for additional claims in Userinfo Endpoint.
     */
    Profile = "profile",
    /**
     * Scope for user email address.
     *
     * See {@link idTokenClaims} for mapped claims in ID Token and {@link userinfoClaims} for additional claims in Userinfo Endpoint.
     */
    Email = "email",
    /**
     * Scope for user phone number.
     *
     * See {@link idTokenClaims} for mapped claims in ID Token and {@link userinfoClaims} for additional claims in Userinfo Endpoint.
     */
    Phone = "phone",
    /**
     * Scope for user's custom data.
     *
     * See {@link idTokenClaims} for mapped claims in ID Token and {@link userinfoClaims} for additional claims in Userinfo Endpoint.
     */
    CustomData = "custom_data",
    /**
     * Scope for user's social identity details.
     *
     * See {@link idTokenClaims} for mapped claims in ID Token and {@link userinfoClaims} for additional claims in Userinfo Endpoint.
     */
    Identities = "identities"
}
export type LogtoRequestErrorBody = {
    code: string;
    message: string;
};
export type Requester = <T>(...args: Parameters<typeof fetch>) => Promise<T>;
export type FetchTokenByAuthorizationCodeParameters = {
    clientId: string;
    tokenEndpoint: string;
    redirectUri: string;
    codeVerifier: string;
    code: string;
    resource?: string;
};
export type FetchTokenByRefreshTokenParameters = {
    clientId: string;
    tokenEndpoint: string;
    refreshToken: string;
    resource?: string;
    scopes?: string[];
};
type SnakeCaseCodeTokenResponse = {
    access_token: string;
    refresh_token?: string;
    id_token: string;
    scope: string;
    expires_in: number;
};
export type CodeTokenResponse = KeysToCamelCase<SnakeCaseCodeTokenResponse>;
type SnakeCaseRefreshTokenTokenResponse = {
    access_token: string;
    refresh_token: string;
    id_token?: string;
    scope: string;
    expires_in: number;
};
export type RefreshTokenTokenResponse = KeysToCamelCase<SnakeCaseRefreshTokenTokenResponse>;
export const fetchTokenByAuthorizationCode: ({ clientId, tokenEndpoint, redirectUri, codeVerifier, code, resource, }: FetchTokenByAuthorizationCodeParameters, requester: Requester) => Promise<CodeTokenResponse>;
export const fetchTokenByRefreshToken: ({ clientId, tokenEndpoint, refreshToken, resource, scopes }: FetchTokenByRefreshTokenParameters, requester: Requester) => Promise<RefreshTokenTokenResponse>;
type OidcConfigSnakeCaseResponse = {
    authorization_endpoint: string;
    token_endpoint: string;
    userinfo_endpoint: string;
    end_session_endpoint: string;
    revocation_endpoint: string;
    jwks_uri: string;
    issuer: string;
};
export const discoveryPath = "/oidc/.well-known/openid-configuration";
export type OidcConfigResponse = KeysToCamelCase<OidcConfigSnakeCaseResponse>;
export const fetchOidcConfig: (endpoint: string, requester: Requester) => Promise<OidcConfigResponse>;
export const revoke: (revocationEndpoint: string, clientId: string, token: string, requester: Requester) => Promise<void>;
export const isArbitraryObject: (data: unknown) => data is Record<string, unknown>;
declare const logtoErrorCodes: Readonly<{
    id_token: {
        invalid_iat: string;
        invalid_token: string;
    };
    callback_uri_verification: {
        redirect_uri_mismatched: string;
        error_found: string;
        missing_state: string;
        state_mismatched: string;
        missing_code: string;
    };
    crypto_subtle_unavailable: "Crypto.subtle is unavailable in insecure contexts (non-HTTPS).";
    unexpected_response_error: "Unexpected response error from the server.";
}>;
export type LogtoErrorCode = NormalizeKeyPaths<typeof logtoErrorCodes>;
export class LogtoError extends Error {
    code: LogtoErrorCode;
    data: unknown;
    constructor(code: LogtoErrorCode, data?: unknown);
}
export const isLogtoRequestError: (data: unknown) => data is {
    code: string;
    message: string;
};
export class LogtoRequestError extends Error {
    code: string;
    constructor(code: string, message: string);
}
export class OidcError {
    error: string;
    errorDescription?: string | undefined;
    constructor(error: string, errorDescription?: string | undefined);
}
export const parseUriParameters: (uri: string) => URLSearchParams;
export const verifyAndParseCodeFromCallbackUri: (callbackUri: string, redirectUri: string, state: string) => string;
export type IdTokenClaims = {
    iss: string;
    sub: string;
    aud: string;
    exp: number;
    iat: number;
    at_hash?: Nullable<string>;
    name?: Nullable<string>;
    username?: Nullable<string>;
    picture?: Nullable<string>;
    email?: Nullable<string>;
    email_verified?: boolean;
    phone_number?: Nullable<string>;
    phone_number_verified?: boolean;
};
export const verifyIdToken: (idToken: string, clientId: string, issuer: string, jwks: JWTVerifyGetKey) => Promise<void>;
export const decodeIdToken: (token: string) => IdTokenClaims;
/**
 * @param originalScopes
 * @return scopes should contain all default scopes (`openid`, `offline_access` and `profile`)
 */
export const withDefaultScopes: (originalScopes?: string[]) => string;
export type SignInUriParameters = {
    authorizationEndpoint: string;
    clientId: string;
    redirectUri: string;
    codeChallenge: string;
    state: string;
    scopes?: string[];
    resources?: string[];
    prompt?: Prompt;
};
export const generateSignInUri: ({ authorizationEndpoint, clientId, redirectUri, codeChallenge, state, scopes, resources, prompt, }: SignInUriParameters) => string;
type SignOutUriParameters = {
    endSessionEndpoint: string;
    clientId: string;
    postLogoutRedirectUri?: string;
};
export const generateSignOutUri: ({ endSessionEndpoint, clientId, postLogoutRedirectUri, }: SignOutUriParameters) => string;
type Identity = {
    userId: string;
    details?: Record<string, unknown>;
};
export type UserInfoResponse = {
    sub: string;
    name?: Nullable<string>;
    username?: Nullable<string>;
    picture?: Nullable<string>;
    email?: Nullable<string>;
    email_verified?: boolean;
    phone_number?: Nullable<string>;
    phone_number_verified?: boolean;
    custom_data?: unknown;
    identities?: Record<string, Identity>;
};
export const fetchUserInfo: (userInfoEndpoint: string, accessToken: string, requester: Requester) => Promise<UserInfoResponse>;

//# sourceMappingURL=index.d.ts.map
