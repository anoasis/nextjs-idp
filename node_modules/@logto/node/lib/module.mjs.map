{"mappings":";;;;;;;AAAA;;;ACAA,+GAA+G,GAC/G;;AAIA;;CAEC,GACD,MAAM,6CAAuB,CAAC,SAAS,EAAE,GACvC,CAAA,GAAA,qBAAa,EAAE,CAAA,GAAA,qBAAa,EAAE,IAAI,WAAW,UAAU,IAAI;AAKtD,MAAM,4CAAgB,IAAM;AAO5B,MAAM,4CAAuB,IAAM;AAQnC,MAAM,4CAAwB,OAAO,eAA0C;IACpF,MAAM,sBAAsB,IAAI,cAAc,MAAM,CAAC;IACrD,MAAM,OAAO,CAAA,GAAA,iBAAS,EAAE;IACxB,KAAK,MAAM,CAAC;IACZ,MAAM,gBAAgB,KAAK,MAAM;IAEjC,OAAO,CAAA,GAAA,qBAAc,AAAD,EAAE,eAAe,IAAI;AAC3C;;;;;;ADPe,uDAA0B,CAAA,GAAA,kBAAS;IAChD,YAAY,MAAmB,EAAE,OAAoD,CAAE;QACrF,KAAK,CAAC,QAAQ;YACZ,GAAG,OAAO;YACV,WAAW,CAAA,GAAA,sBAAc,EACvB,OAAO,SAAS,GACZ,OAAO,GAAG,OAAmC;gBAC3C,MAAM,CAAC,OAAO,KAAK,GAAG;gBAEtB,OAAO,CAAA,GAAA,gBAAK,AAAD,EAAE,OAAO;oBAClB,GAAG,IAAI;oBACP,SAAS;wBACP,eAAe,CAAC,MAAM,EAAE,iCAAO,IAAI,CACjC,4EAA4E;wBAC5E,CAAC,EAAE,OAAO,KAAK,CAAC,CAAC,EAAE,OAAO,SAAS,CAAC,CAAC,EACrC,QACA,QAAQ,CAAC,UAAU,CAAC;wBACtB,GAAG,MAAM,OAAO;oBAClB;gBACF;YACF,IACA,CAAA,GAAA,gBAAI,CAAC;mCAEX;kCACA;2BACA;QACF;IACF;IAEA,aAAa,OAAO,kBAClB,eAAc,YACd,SAAQ,iBACR,cAAa,EACQ,GAAG,CAAC,CAAC,GAA4B;QACtD,MAAM,kBAAkB,MAAM,IAAI,CAAC,eAAe;QAElD,IAAI,CAAC,iBACH,OAAO;6BACL;QACF;QAGF,MAAM,SAAS,MAAM,IAAI,CAAC,gBAAgB;QAE1C,IAAI,CAAC,gBACH,OAAO;6BACL;oBACA;YACA,UAAU,CAAA,GAAA,kBAAU,EAAE,iBAAkB,MAAM,IAAI,CAAC,aAAa;QAClE;QAGF,IAAI;YACF,MAAM,cAAc,MAAM,IAAI,CAAC,cAAc,CAAC;YAE9C,OAAO;iCACL;gBACA,QAAQ,MAAM,IAAI,CAAC,gBAAgB;gBACnC,UAAU,CAAA,GAAA,kBAAU,EAAE,iBAAkB,MAAM,IAAI,CAAC,aAAa;6BAChE;YACF;QACF,EAAE,OAAM;YACN,OAAO;gBACL,iBAAiB,KAAK;YACxB;QACF;IACF,EAAE;AACJ","sources":["packages/node/src/index.ts","packages/node/src/utils/generators.ts"],"sourcesContent":["import type { LogtoConfig, ClientAdapter } from '@logto/client';\nimport BaseClient, { createRequester } from '@logto/client';\nimport { conditional } from '@silverhand/essentials';\nimport fetch from 'node-fetch';\n\nimport type { GetContextParameters, LogtoContext } from './types';\nimport { generateCodeChallenge, generateCodeVerifier, generateState } from './utils/generators';\n\nexport type { LogtoContext, GetContextParameters } from './types';\n\nexport type {\n  IdTokenClaims,\n  LogtoErrorCode,\n  LogtoConfig,\n  LogtoClientErrorCode,\n  Storage,\n  StorageKey,\n} from '@logto/client';\n\nexport {\n  LogtoError,\n  OidcError,\n  Prompt,\n  LogtoRequestError,\n  LogtoClientError,\n  ReservedScope,\n  UserScope,\n} from '@logto/client';\n\nexport default class LogtoClient extends BaseClient {\n  constructor(config: LogtoConfig, adapter: Pick<ClientAdapter, 'navigate' | 'storage'>) {\n    super(config, {\n      ...adapter,\n      requester: createRequester(\n        config.appSecret\n          ? async (...args: Parameters<typeof fetch>) => {\n              const [input, init] = args;\n\n              return fetch(input, {\n                ...init,\n                headers: {\n                  Authorization: `basic ${Buffer.from(\n                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                    `${config.appId}:${config.appSecret}`,\n                    'utf8'\n                  ).toString('base64')}`,\n                  ...init?.headers,\n                },\n              });\n            }\n          : fetch\n      ),\n      generateCodeChallenge,\n      generateCodeVerifier,\n      generateState,\n    });\n  }\n\n  getContext = async ({\n    getAccessToken,\n    resource,\n    fetchUserInfo,\n  }: GetContextParameters = {}): Promise<LogtoContext> => {\n    const isAuthenticated = await this.isAuthenticated();\n\n    if (!isAuthenticated) {\n      return {\n        isAuthenticated,\n      };\n    }\n\n    const claims = await this.getIdTokenClaims();\n\n    if (!getAccessToken) {\n      return {\n        isAuthenticated,\n        claims,\n        userInfo: conditional(fetchUserInfo && (await this.fetchUserInfo())),\n      };\n    }\n\n    try {\n      const accessToken = await this.getAccessToken(resource);\n\n      return {\n        isAuthenticated,\n        claims: await this.getIdTokenClaims(),\n        userInfo: conditional(fetchUserInfo && (await this.fetchUserInfo())),\n        accessToken,\n      };\n    } catch {\n      return {\n        isAuthenticated: false,\n      };\n    }\n  };\n}\n","/** @link [Proof Key for Code Exchange by OAuth Public Clients](https://datatracker.ietf.org/doc/html/rfc7636) */\nimport { randomFillSync, createHash } from 'crypto';\n\nimport { fromUint8Array } from 'js-base64';\n\n/**\n * @param length The length of the raw random data.\n */\nconst generateRandomString = (length = 64) =>\n  fromUint8Array(randomFillSync(new Uint8Array(length)), true);\n\n/**\n * Generates random string for state and encodes them in url safe base64\n */\nexport const generateState = () => generateRandomString();\n\n/**\n * Generates code verifier\n *\n * @link [Client Creates a Code Verifier](https://datatracker.ietf.org/doc/html/rfc7636#section-4.1)\n */\nexport const generateCodeVerifier = () => generateRandomString();\n\n/**\n * Calculates the S256 PKCE code challenge for an arbitrary code verifier and encodes it in url safe base64\n *\n * @param {String} codeVerifier Code verifier to calculate the S256 code challenge for\n * @link [Client Creates the Code Challenge](https://datatracker.ietf.org/doc/html/rfc7636#section-4.2)\n */\nexport const generateCodeChallenge = async (codeVerifier: string): Promise<string> => {\n  const encodedCodeVerifier = new TextEncoder().encode(codeVerifier);\n  const hash = createHash('sha256');\n  hash.update(encodedCodeVerifier);\n  const codeChallenge = hash.digest();\n\n  return fromUint8Array(codeChallenge, true);\n};\n"],"names":[],"version":3,"file":"module.mjs.map"}