var $4R6L3$logtojs = require("@logto/js");
var $4R6L3$jose = require("jose");
var $4R6L3$lodashonce = require("lodash.once");
var $4R6L3$lodashget = require("lodash.get");

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $parcel$defineInteropFlag(a) {
  Object.defineProperty(a, '__esModule', {value: true, configurable: true});
}
function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$defineInteropFlag(module.exports);

$parcel$export(module.exports, "default", () => $f73788ae50447ce9$export$2e2bcd8739ae039);
$parcel$export(module.exports, "LogtoError", () => $f73788ae50447ce9$re_export$LogtoError);
$parcel$export(module.exports, "OidcError", () => $f73788ae50447ce9$re_export$OidcError);
$parcel$export(module.exports, "Prompt", () => $4R6L3$logtojs.Prompt);
$parcel$export(module.exports, "LogtoRequestError", () => $f73788ae50447ce9$re_export$LogtoRequestError);
$parcel$export(module.exports, "ReservedScope", () => $f73788ae50447ce9$re_export$ReservedScope);
$parcel$export(module.exports, "UserScope", () => $f73788ae50447ce9$re_export$UserScope);
$parcel$export(module.exports, "createRequester", () => $b455f57f80fbf6bf$export$8d54726fdbf08e0a);



var $9166104b36889c59$exports = {};

$parcel$export($9166104b36889c59$exports, "LogtoClientError", () => $9166104b36889c59$export$877962ca249b8fc8);

const $9166104b36889c59$var$logtoClientErrorCodes = Object.freeze({
    sign_in_session: {
        invalid: "Invalid sign-in session.",
        not_found: "Sign-in session not found."
    },
    not_authenticated: "Not authenticated.",
    get_access_token_by_refresh_token_failed: "Failed to get access token by refresh token.",
    fetch_user_info_failed: "Unable to fetch user info. The access token may be invalid.",
    invalid_id_token: "Invalid id token."
});
const $9166104b36889c59$var$getMessageByErrorCode = (errorCode)=>{
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const message = (0, ($parcel$interopDefault($4R6L3$lodashget)))($9166104b36889c59$var$logtoClientErrorCodes, errorCode);
    if (typeof message === "string") return message;
    return errorCode;
};
class $9166104b36889c59$export$877962ca249b8fc8 extends Error {
    constructor(code, data){
        super($9166104b36889c59$var$getMessageByErrorCode(code));
        this.code = code;
        this.data = data;
    }
}


var $6d3989f7f53311af$exports = {};

$parcel$export($6d3989f7f53311af$exports, "isLogtoSignInSessionItem", () => $6d3989f7f53311af$export$5d8adf6e063019de);
$parcel$export($6d3989f7f53311af$exports, "isLogtoAccessTokenMap", () => $6d3989f7f53311af$export$c12fab42a9a3e2a6);

const $6d3989f7f53311af$export$5d8adf6e063019de = (data)=>{
    if (!(0, $4R6L3$logtojs.isArbitraryObject)(data)) return false;
    return [
        "redirectUri",
        "codeVerifier",
        "state"
    ].every((key)=>typeof data[key] === "string");
};
const $6d3989f7f53311af$export$c12fab42a9a3e2a6 = (data)=>{
    if (!(0, $4R6L3$logtojs.isArbitraryObject)(data)) return false;
    return Object.values(data).every((value)=>{
        if (!(0, $4R6L3$logtojs.isArbitraryObject)(value)) return false;
        return typeof value.token === "string" && typeof value.scope === "string" && typeof value.expiresAt === "number";
    });
};




const $b455f57f80fbf6bf$export$8d54726fdbf08e0a = (fetchFunction)=>{
    return async (...args)=>{
        const response = await fetchFunction(...args);
        if (!response.ok) {
            const responseJson = await response.json();
            if (!(0, $4R6L3$logtojs.isLogtoRequestError)(responseJson)) throw new (0, $4R6L3$logtojs.LogtoError)("unexpected_response_error", responseJson);
            // Expected request error from server
            const { code: code , message: message  } = responseJson;
            throw new (0, $4R6L3$logtojs.LogtoRequestError)(code, message);
        }
        return response.json();
    };
};


const $e2aabdbdb3cc09f0$export$8f595bd2a47bcea6 = (resource = "", scopes = [])=>`${scopes.slice().sort().join(" ")}@${resource}`;
const $e2aabdbdb3cc09f0$export$5d9c34f69c80822b = (endpoint)=>new URL((0, $4R6L3$logtojs.discoveryPath), endpoint).toString();






class $f73788ae50447ce9$export$2e2bcd8739ae039 {
    getOidcConfig = (0, ($parcel$interopDefault($4R6L3$lodashonce)))(this._getOidcConfig);
    getJwtVerifyGetKey = (0, ($parcel$interopDefault($4R6L3$lodashonce)))(this._getJwtVerifyGetKey);
    accessTokenMap = new Map();
    constructor(logtoConfig, adapter){
        this.logtoConfig = {
            ...logtoConfig,
            prompt: logtoConfig.prompt ?? (0, $4R6L3$logtojs.Prompt).Consent,
            scopes: (0, $4R6L3$logtojs.withDefaultScopes)(logtoConfig.scopes).split(" ")
        };
        this.adapter = adapter;
        this.loadAccessTokenMap();
    }
    async isAuthenticated() {
        return Boolean(await this.getIdToken());
    }
    async getRefreshToken() {
        return this.adapter.storage.getItem("refreshToken");
    }
    async getIdToken() {
        return this.adapter.storage.getItem("idToken");
    }
    async getAccessToken(resource) {
        if (!await this.getIdToken()) throw new (0, $9166104b36889c59$export$877962ca249b8fc8)("not_authenticated");
        const accessTokenKey = (0, $e2aabdbdb3cc09f0$export$8f595bd2a47bcea6)(resource);
        const accessToken = this.accessTokenMap.get(accessTokenKey);
        if (accessToken && accessToken.expiresAt > Date.now() / 1000) return accessToken.token;
        // Since the access token has expired, delete it from the map.
        if (accessToken) this.accessTokenMap.delete(accessTokenKey);
        /**
     * Need to fetch a new access token using refresh token.
     */ return this.getAccessTokenByRefreshToken(resource);
    }
    async getIdTokenClaims() {
        const idToken = await this.getIdToken();
        if (!idToken) throw new (0, $9166104b36889c59$export$877962ca249b8fc8)("not_authenticated");
        return (0, $4R6L3$logtojs.decodeIdToken)(idToken);
    }
    async fetchUserInfo() {
        const { userinfoEndpoint: userinfoEndpoint  } = await this.getOidcConfig();
        const accessToken = await this.getAccessToken();
        if (!accessToken) throw new (0, $9166104b36889c59$export$877962ca249b8fc8)("fetch_user_info_failed");
        return (0, $4R6L3$logtojs.fetchUserInfo)(userinfoEndpoint, accessToken, this.adapter.requester);
    }
    async signIn(redirectUri) {
        const { appId: clientId , prompt: prompt , resources: resources , scopes: scopes  } = this.logtoConfig;
        const { authorizationEndpoint: authorizationEndpoint  } = await this.getOidcConfig();
        const codeVerifier = this.adapter.generateCodeVerifier();
        const codeChallenge = await this.adapter.generateCodeChallenge(codeVerifier);
        const state = this.adapter.generateState();
        const signInUri = (0, $4R6L3$logtojs.generateSignInUri)({
            authorizationEndpoint: authorizationEndpoint,
            clientId: clientId,
            redirectUri: redirectUri,
            codeChallenge: codeChallenge,
            state: state,
            scopes: scopes,
            resources: resources,
            prompt: prompt
        });
        await this.setSignInSession({
            redirectUri: redirectUri,
            codeVerifier: codeVerifier,
            state: state
        });
        await this.setRefreshToken(null);
        await this.setIdToken(null);
        this.adapter.navigate(signInUri);
    }
    async isSignInRedirected(url) {
        const signInSession = await this.getSignInSession();
        if (!signInSession) return false;
        const { redirectUri: redirectUri  } = signInSession;
        const { origin: origin , pathname: pathname  } = new URL(url);
        return `${origin}${pathname}` === redirectUri;
    }
    async handleSignInCallback(callbackUri) {
        const { logtoConfig: logtoConfig , adapter: adapter  } = this;
        const { requester: requester  } = adapter;
        const signInSession = await this.getSignInSession();
        if (!signInSession) throw new (0, $9166104b36889c59$export$877962ca249b8fc8)("sign_in_session.not_found");
        const { redirectUri: redirectUri , state: state , codeVerifier: codeVerifier  } = signInSession;
        const code = (0, $4R6L3$logtojs.verifyAndParseCodeFromCallbackUri)(callbackUri, redirectUri, state);
        const { appId: clientId  } = logtoConfig;
        const { tokenEndpoint: tokenEndpoint  } = await this.getOidcConfig();
        const codeTokenResponse = await (0, $4R6L3$logtojs.fetchTokenByAuthorizationCode)({
            clientId: clientId,
            tokenEndpoint: tokenEndpoint,
            redirectUri: redirectUri,
            codeVerifier: codeVerifier,
            code: code
        }, requester);
        await this.verifyIdToken(codeTokenResponse.idToken);
        await this.saveCodeToken(codeTokenResponse);
        await this.setSignInSession(null);
    }
    async signOut(postLogoutRedirectUri) {
        const idToken = await this.getIdToken();
        if (!idToken) throw new (0, $9166104b36889c59$export$877962ca249b8fc8)("not_authenticated");
        const { appId: clientId  } = this.logtoConfig;
        const { endSessionEndpoint: endSessionEndpoint , revocationEndpoint: revocationEndpoint  } = await this.getOidcConfig();
        const refreshToken = await this.getRefreshToken();
        if (refreshToken) try {
            await (0, $4R6L3$logtojs.revoke)(revocationEndpoint, clientId, refreshToken, this.adapter.requester);
        } catch  {
        // Do nothing at this point, as we don't want to break the sign-out flow even if the revocation is failed
        }
        const url = (0, $4R6L3$logtojs.generateSignOutUri)({
            endSessionEndpoint: endSessionEndpoint,
            postLogoutRedirectUri: postLogoutRedirectUri,
            clientId: clientId
        });
        this.accessTokenMap.clear();
        await this.setRefreshToken(null);
        await this.setIdToken(null);
        await this.adapter.storage.removeItem("accessToken");
        this.adapter.navigate(url);
    }
    async getSignInSession() {
        const jsonItem = await this.adapter.storage.getItem("signInSession");
        if (!jsonItem) return null;
        const item = JSON.parse(jsonItem);
        if (!(0, $6d3989f7f53311af$export$5d8adf6e063019de)(item)) throw new (0, $9166104b36889c59$export$877962ca249b8fc8)("sign_in_session.invalid");
        return item;
    }
    async setSignInSession(logtoSignInSessionItem) {
        if (!logtoSignInSessionItem) {
            await this.adapter.storage.removeItem("signInSession");
            return;
        }
        const jsonItem = JSON.stringify(logtoSignInSessionItem);
        await this.adapter.storage.setItem("signInSession", jsonItem);
    }
    async setIdToken(idToken) {
        if (!idToken) {
            await this.adapter.storage.removeItem("idToken");
            return;
        }
        await this.adapter.storage.setItem("idToken", idToken);
    }
    async setRefreshToken(refreshToken) {
        if (!refreshToken) {
            await this.adapter.storage.removeItem("refreshToken");
            return;
        }
        await this.adapter.storage.setItem("refreshToken", refreshToken);
    }
    async getAccessTokenByRefreshToken(resource) {
        const currentRefreshToken = await this.getRefreshToken();
        if (!currentRefreshToken) throw new (0, $9166104b36889c59$export$877962ca249b8fc8)("not_authenticated");
        try {
            const accessTokenKey = (0, $e2aabdbdb3cc09f0$export$8f595bd2a47bcea6)(resource);
            const { appId: clientId  } = this.logtoConfig;
            const { tokenEndpoint: tokenEndpoint  } = await this.getOidcConfig();
            const { accessToken: accessToken , refreshToken: refreshToken , idToken: idToken , scope: scope , expiresIn: expiresIn  } = await (0, $4R6L3$logtojs.fetchTokenByRefreshToken)({
                clientId: clientId,
                tokenEndpoint: tokenEndpoint,
                refreshToken: currentRefreshToken,
                resource: resource
            }, this.adapter.requester);
            this.accessTokenMap.set(accessTokenKey, {
                token: accessToken,
                scope: scope,
                expiresAt: Math.round(Date.now() / 1000) + expiresIn
            });
            await this.saveAccessTokenMap();
            await this.setRefreshToken(refreshToken);
            if (idToken) {
                await this.verifyIdToken(idToken);
                await this.setIdToken(idToken);
            }
            return accessToken;
        } catch (error) {
            throw new (0, $9166104b36889c59$export$877962ca249b8fc8)("get_access_token_by_refresh_token_failed", error);
        }
    }
    async _getOidcConfig() {
        const { endpoint: endpoint  } = this.logtoConfig;
        const discoveryEndpoint = (0, $e2aabdbdb3cc09f0$export$5d9c34f69c80822b)(endpoint);
        return (0, $4R6L3$logtojs.fetchOidcConfig)(discoveryEndpoint, this.adapter.requester);
    }
    async _getJwtVerifyGetKey() {
        const { jwksUri: jwksUri  } = await this.getOidcConfig();
        return (0, $4R6L3$jose.createRemoteJWKSet)(new URL(jwksUri));
    }
    async verifyIdToken(idToken) {
        const { appId: appId  } = this.logtoConfig;
        const { issuer: issuer  } = await this.getOidcConfig();
        const jwtVerifyGetKey = await this.getJwtVerifyGetKey();
        try {
            await (0, $4R6L3$logtojs.verifyIdToken)(idToken, appId, issuer, jwtVerifyGetKey);
        } catch (error) {
            throw new (0, $9166104b36889c59$export$877962ca249b8fc8)("invalid_id_token", error);
        }
    }
    async saveCodeToken({ refreshToken: refreshToken , idToken: idToken , scope: scope , accessToken: accessToken , expiresIn: expiresIn  }) {
        await this.setRefreshToken(refreshToken ?? null);
        await this.setIdToken(idToken);
        // NOTE: Will add scope to accessTokenKey when needed. (Linear issue LOG-1589)
        const accessTokenKey = (0, $e2aabdbdb3cc09f0$export$8f595bd2a47bcea6)();
        const expiresAt = Date.now() / 1000 + expiresIn;
        this.accessTokenMap.set(accessTokenKey, {
            token: accessToken,
            scope: scope,
            expiresAt: expiresAt
        });
        await this.saveAccessTokenMap();
    }
    async saveAccessTokenMap() {
        const data = {};
        for (const [key, accessToken] of this.accessTokenMap.entries())// eslint-disable-next-line @silverhand/fp/no-mutation
        data[key] = accessToken;
        await this.adapter.storage.setItem("accessToken", JSON.stringify(data));
    }
    async loadAccessTokenMap() {
        const raw = await this.adapter.storage.getItem("accessToken");
        if (!raw) return;
        try {
            const json = JSON.parse(raw);
            if (!(0, $6d3989f7f53311af$export$c12fab42a9a3e2a6)(json)) return;
            this.accessTokenMap.clear();
            for (const [key, accessToken] of Object.entries(json))this.accessTokenMap.set(key, accessToken);
        } catch  {}
    }
}
$parcel$exportWildcard(module.exports, $9166104b36889c59$exports);
$parcel$exportWildcard(module.exports, $6d3989f7f53311af$exports);


//# sourceMappingURL=index.js.map
